<template lang="html">
	<div v-if="options.length > 0">
		<!-- If there's a title, show it -->
		<h3 v-if="title || schema.title" :class="mode === 'view' ? 'inline' : ''">
			{{ (title || schema.title) + (mode === 'view' ? ':' : '') }}
			<a v-if="helpMessageName && mode === 'edit'" class="help-link" @click="$emit('show-help')">
				<HelpCircleIcon />
			</a>
		</h3>
		<!-- Same deal with description -->
		<p v-if="description && mode === 'edit'">
			{{ description }}
		</p>
		<!-- A list to hold each of the options -->
		<transition-group
			v-if="mode === 'edit'"
			name="list-complete"
			tag="ul"
			class="plain"
		>
			<li v-for="option in options" :key="option[optionID]" class="list-complete-item">
				<!-- Create a label to hold the option elements -->
				<label>
					<!--
						A radio input for the option, props as follows:
						name: All options use the schema title so that only one can be checked
						value: Set to a record generated from the option
						v-model: Tells vue to store the value in the component's records array
						disabled: Bound to whether editing is allowed or not
					-->
					<input
						v-model="computedRecord"
						type="radio"
						:name="schema.title"
						:value="generateRecord(option)"
						@click="notifyOfChanges"
					/>
					<!-- Option's label or ID -->
					<span>
						{{ option[optionLabel || optionID] }}
					</span>
					<!-- Description if there is one -->
					<span v-if="optionDescription">
						: {{ option[optionDescription] }}
					</span>
				</label>
			</li>
		</transition-group>
		<div v-else class="inline">
			<span
				v-for="option in selectedOptions"
				:key="option[optionID]"
			>
				{{ option[optionLabel || optionID] }}
			</span>
		</div>
	</div>
</template>

<script>
	/* global activeUserID */
	/* global notify */

	// Import required modules
	import HelpCircleIcon from 'vue-feather-icons/icons/HelpCircleIcon';
	import { constructNotificationMessage } from '~/modules/notifications';
	import {
		getCriteriaStructure,
		logError
	} from '~/modules/caesdb';
	import {
		modeValidator,
		stringFormats
	} from '~/modules/utilities';

	// Export the actual component
	export default {
		// Component's name
		name: 'Radio',
		components: { HelpCircleIcon },
		props: {
			affects: {
				type: Object,
				default: null
			},
			associatedColumn: {
				type: String,
				required: true
			},
			description: {
				type: String,
				default: ''
			},
			filter: {
				type: Object,
				default: null
			},
			helpMessageName: {
				type: String,
				default: ''
			},
			identifier: {
				type: Object,
				default: null
			},
			mode: {
				type: String,
				default: 'view',
				validator: modeValidator
			},
			schema: {
				type: Object,
				required: true
			},
			title: {
				type: String,
				default: ''
			}
		},
		data () {
			const data = {
				localRecords: [],
				optionID: null,
				optionLabel: null,
				optionDescription: null,
				unfilteredOptions: [],
				filterRecords: [],
				record: null,
				changeCount: 0
			};
			for (let i = 0; i < this.schema.columns.length; ++i) {
				const column = this.schema.columns[i];
				if (column.columnName === this.associatedColumn && column.constraint) {
					data.optionID = column.constraint.foreignKey;
					data.optionLabel = column.constraint.foreignLabel;
					data.optionDescription = column.constraint.foreignDescription || false;
				}
			}

			return data;
		},

		// Computed values are values that are generated by a function rather than
		// just plain variables
		computed: {
			associatedColumnSchema: {
				get () {
					return this.schema.columns
						.filter(c => c.columnName === this.associatedColumn)
						.reduce(c => c);
				}
			},
			computedRecord: {
				get () {
					return this.$store.state[stringFormats.camelCase(this.title || this.schema.title)].records[0] || null;

					// Return this.record;
				},
				set (val) {
					if (this.$store.state[stringFormats.camelCase(this.title || this.schema.title)].records.length > 0) this.$store.state[stringFormats.camelCase(this.title || this.schema.title)].records.pop();
					this.$store.state[stringFormats.camelCase(this.title || this.schema.title)].records.push(val);
				}
			},
			duplication () {
				return this.$store.state.duplication;
			},
			fetched: {
				get () { return this.$store.state[stringFormats.camelCase(this.title || this.schema.title)].fetched; },
				set (val) { this.$store.state[stringFormats.camelCase(this.title || this.schema.title)].fetched = val; }
			},
			filterLoaded: {
				get () {
					return this.filterRecords.length > 0;
				}
			},
			options: {
				get () {
					if (!this.filter) return this.unfilteredOptions;
					if (!this.filterLoaded) return [];
					const associationRecords = this.$store.state[stringFormats.camelCase(this.filter.association.title)].records.map(r => r[this.filter.association.column]);
					const validOptionValues = [];
					this.filterRecords.forEach(record => {
						const associationRecordIndex = associationRecords.indexOf(record[this.filter.associatedColumn]);
						if (associationRecordIndex !== -1 && validOptionValues.indexOf(record[this.filter.optionColumn]) === -1) validOptionValues.push(record[this.filter.optionColumn]);
					});
					const options = [];
					this.unfilteredOptions.forEach(option => {
						if (validOptionValues.indexOf(option[this.associatedColumnSchema.constraint.foreignKey]) !== -1) options.push(option);
					});

					return options;
				}
			},
			selectedOptions () {
				return this.options.filter(o => this.computedRecord && this.computedRecord[this.associatedColumn] === o[this.optionID]);
			},
			showNotifications () { return this.$store.state.preferences.showNotificationsForChanges; }
		},
		watch: {
			// ComputedRecord (val) {
			// 	this.records = [val];
			// },
			duplication: {
				handler () {
					if (this.identifier.duplicate && this.duplication.associations[stringFormats.camelCase(this.title || this.schema.title)]) this.getRecords();
				},
				deep: true
			}
		},
		mounted () {
			const component = this;

			const getOptions = () => {
				component.schema.columns.forEach(column => {
					if (column.columnName === component.associatedColumn && column.constraint && column.constraint.values && column.constraint.values.length > 0) {
						const values = [];
						const unfilteredOptions = [];
						column.constraint.values.forEach(value => {
							if (value.originalValue) {
								unfilteredOptions.push(value.originalValue);
								values.push(value);
							} else {
								const newValue = {
									key: value[column.constraint.foreignKey],
									label: column.constraint.foreignLabel ? value[column.constraint.foreignLabel] : value[column.constraint.foreignKey],
									originalValue: value
								};
								values.push(newValue);
								unfilteredOptions.push(value);
							}
						});
						component.unfilteredOptions = unfilteredOptions;
						column.constraint.values = values;
					} else if (column.columnName === component.associatedColumn && column.constraint && column.constraint.getValues) {
						if (column.constraint.tablePrefix)

							// If the constraint has a tablePrefix, we need to get a criteria
							getCriteriaStructure(column.constraint.databaseName, column.constraint.tablePrefix, (err, criteriaStructure) => {
								if (err) logError(err);
								criteriaStructure[column.constraint.criteria.string] = column.constraint.criteria.useUserID ? activeUserID : column.constraint.criteria.value;
								column.constraint.getValues(criteriaStructure, (err, data) => {
									if (err) logError(err);
									if (data) {
										component.unfilteredOptions = data;
										const values = [];
										data.forEach(result => {
											const value = {
												key: result[column.constraint.foreignKey],
												label: column.constraint.foreignLabel ? result[column.constraint.foreignLabel] : result[column.constraint.foreignKey],
												originalValue: result
											};
											values.push(value);
										});
										column.constraint.values = values;
									}

									// If (data) component.unfilteredOptions = data;
								});
							});
						else

							// If no table prefix, just fetch the data
							column.constraint.getValues((err, data) => {
								if (err) logError(err);
								if (data) {
									component.unfilteredOptions = data;
									const values = [];
									data.forEach(result => {
										const value = {
											key: result[column.constraint.foreignKey],
											label: column.constraint.foreignLabel ? result[column.constraint.foreignLabel] : result[column.constraint.foreignKey],
											originalValue: result
										};
										values.push(value);
									});
									column.constraint.values = values;
								}

								// If (data) component.unfilteredOptions = data;
							});
					} else if (column.columnName === component.associatedColumn && column.constraint.values.length < 1) {
						logError(new Error('ID Column does not have necessary constraint information.'));
					}
				});
			};

			const getFilterRecords = () => {
				if (component.filter.getValues) component.filter.getValues((err, data) => {
					if (err) logError(err);
					if (data) component.filterRecords = data;
				});
				else logError(new Error('Filter does not contain function to get values'));
			};

			getOptions();
			if (!component.identifier.duplicate && component.identifier.value || component.identifier.duplicate && this.duplication.associations[stringFormats.camelCase(this.title || this.schema.title)]) if (!this.fetched) this.getRecords();

			if (component.filter) getFilterRecords();
		},
		methods: {
			generateRecord (option) {
				const record = {};
				this.schema.columns.forEach(column => {
					if (column.columnName === this.associatedColumn) record[column.columnName] = option[this.optionID];
					else record[column.columnName] = this.identifier.value || null;
				});

				return record;
			},
			getRecords () {
				getCriteriaStructure(this.schema.databaseName, this.schema.tablePrefix, (err, data) => {
					if (err) logError(err);
					if (data) {
						const critStruct = data;
						critStruct[this.identifier.criteriaString] = this.identifier.value;
						this.schema.fetchExisting(critStruct, (err, data) => {
							if (err) logError(err);
							if (data) {
								if (data.length > 1) console.warn('More than one record retrieved, when only one record should be allowed.  The first record retrieved will be used.');
								const convertedRecord = {};
								this.schema.columns.forEach(column => {
									convertedRecord[column.columnName] = data[0][column.columnName];
								});
								this.computedRecord = convertedRecord;
								this.fetched = true;
							}
						});
					}
				});
			},
			notifyOfChanges () {
				if (!this.showNotifications) return;
				if (this.affects && (this.affects.showAlways || this.changeCount < 1)) {
					const content = constructNotificationMessage(this.title, this.affects.titles);
					const notification = notify.log(content);
					notification.addEventListener('click', e => {
						if (!e.target.matches('.notify-button.hide-notifications')) return;
						this.$store.commit('preferences/hideNotifications');
						Array.from(notification.parentNode.children).forEach(el => {
							el.parentNode.removeChild(el);
						});
					});
				}
				++this.changeCount;
			}
		}
	};
</script>

<style lang="scss" scoped>
	ul.plain {
		list-style-type: none;
		padding: 0;
	}
</style>
