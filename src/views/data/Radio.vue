<template lang="html">
  <div>
		<!-- If there's a title, show it -->
		<strong v-if="title || schema.title">
			{{ title || schema.title }}
		</strong>
		<!-- Same deal with description -->
		<!-- <p v-if="description">
			{{ description }}
		</p> -->
		<!-- A list to hold each of the options -->
		<transition-group name="list-complete" tag="ul">
			<li v-for="option in options" v-bind:key="option[optionID]" class="list-complete-item">
				<!-- Create a label to hold the option elements -->
				<label>
					<!--
						A radio input for the option, props as follows:
						name: All options use the schema title so that only one can be checked
						value: Set to a record generated from the option
						v-model: Tells vue to store the value in the component's records array
						disabled: Bound to whether editing is allowed or not
					-->
					<input type="radio" :name="schema.title" :value="generateRecord(option)" v-model="computedRecord" :disabled="!allowEdit" />
					<!-- Option's label or ID -->
					<span>
						{{ option[optionLabel || optionID] }}
					</span>
					<!-- Description if there is one -->
					<span v-if="optionDescription">
						: {{ option[optionDescription] }}
					</span>
				</label>
			</li>
		</transition-group>
	</div>
</template>

<script>
	/* global activeUserID */
	// Import required modules
	import { getCriteriaStructure } from '@/modules/caesdb';
	import { stringFormats } from '@/modules/utilities';
	import {
		cfToJs,
		jsToCf
	} from '@/modules/criteriaUtils';

	// Export the actual component
	export default {
		// Component's name
		name: 'Radio',
		// Computed values are values that are generated by a function rather than
		// just plain variables
		computed: {
			associatedColumnSchema: {
				get () {
					for (let i = 0; i < this.schema.columns.length; ++i) {
						if (this.schema.columns[i].columnName === this.associatedColumn) return this.schema.columns[i];
					}
				}
			},
			computedRecord: {
				get () {
					return this.record;
				},
				set (val) {
					this.record = val;
				}
			},
			filterLoaded: {
				get () {
					return this.filterRecords.length > 0;
				}
			},
			options: {
				get () {
					if (!this.filter) return this.unfilteredOptions;
					if (!this.filterLoaded) return [];
					const associationRecords = this.$store.state[stringFormats.camelCase(this.filter.association.title)].records.map(r => r[this.filter.association.column]);
					let validOptionValues = [];
					this.filterRecords.forEach((record) => {
						const associationRecordIndex = associationRecords.indexOf(record[this.filter.associatedColumn]);
						if (associationRecordIndex !== -1 && validOptionValues.indexOf(record[this.filter.optionColumn]) === -1) {
							validOptionValues.push(record[this.filter.optionColumn]);
						}
					});
					let options = [];
					this.unfilteredOptions.forEach((option) => {
						if (validOptionValues.indexOf(option[this.associatedColumnSchema.constraint.foreignKey]) !== -1) options.push(option);
					});
					return options;
				}
			},
			records: {
				get () {
					return this.$store ? this.$store.state[stringFormats.camelCase(this.title || this.schema.title)].records : this.localRecords;
				},
				set (val) {
					if (this.$store) {
						this.$store.state[stringFormats.camelCase(this.title || this.schema.title)].records = val;
					} else {
						this.localRecords = val;
					}
				}
			}
		},
		data () {
			const data = {
				localRecords: [],
				optionID: null,
				optionLabel: null,
				optionDescription: null,
				unfilteredOptions: [],
				filterRecords: [],
				record: null
			};
			for (let i = 0; i < this.schema.columns.length; ++i) {
				const column = this.schema.columns[i];
				if (column.columnName === this.associatedColumn && column.constraint) {
					data.optionID = column.constraint.foreignKey;
					data.optionLabel = column.constraint.foreignLabel;
					data.optionDescription = column.constraint.foreignDescription || false;
				}
			}
			return data;
		},
		methods: {
			generateRecord (option) {
				const record = {};
				this.schema.columns.forEach((column) => {
					if (column.columnName === this.associatedColumn) {
						record[column.columnName] = option[this.optionID];
					} else {
						record[column.columnName] = this.identifier.value || null;
					}
				});
				return record;
			}
		},
		mounted () {
			const component = this;

			const getRecords = () => {
				getCriteriaStructure(this.schema.tablePrefix, (err, data) => {
					if (err) console.error(err);
					if (data.Message) {
						console.error(new Error(data.Message));
					} else {
						let critStruct = cfToJs(data);
						critStruct[this.identifier.criteriaString] = this.identifier.value;
						this.schema.fetchExisting(jsToCf(critStruct), (err, data) => {
							if (err) console.error(err);
							if (data.Message) {
								console.error(new Error(data.Message));
							} else {
								if (data.length > 1) console.warn('More than one record retrieved, when only one record should be allowed.  The first record retrieved will be used.');
								let convertedRecord = {};
								this.schema.columns.forEach((column) => {
									convertedRecord[column.columnName] = data[0][column.columnName];
								});
								this.computedRecord = convertedRecord;
							}
						});
					}
				});
			};

			const getOptions = () => {
				component.schema.columns.forEach((column) => {
					if (column.columnName === component.associatedColumn && column.constraint && column.constraint.getValues) {
						if (column.constraint.tablePrefix) {
							// If the constraint has a tablePrefix, we need to get a criteria
							getCriteriaStructure(column.constraint.tablePrefix, (err, criteriaStructure) => {
								if (err) console.error(err);
								criteriaStructure[column.constraint.criteria.string] = column.constraint.criteria.useUserID ? activeUserID : column.constraint.criteria.value;
								column.constraint.getValues(criteriaStructure, (err, data) => {
									if (err) console.error(err);
									if (data) component.unfilteredOptions = data;
								});
							});
						} else {
							// If no table prefix, just fetch the data
							column.constraint.getValues((err, data) => {
								if (err) console.error(err);
								if (data) component.unfilteredOptions = data;
							});
						}
					} else if (column.columnName === component.associatedColumn) {
						console.error('ID Column does not have necessary constraint information.');
					}
				});
			};

			const getFilterRecords = () => {
				if (component.filter.getValues) {
					component.filter.getValues((err, data) => {
						if (err) console.error(err);
						if (data) component.filterRecords = data;
					});
				} else {
					console.error('Filter does not contain function to get values');
				}
			};

			getOptions();
			if (component.identifier.value) getRecords();
			if (component.filter) getFilterRecords();
		},
		props: {
			'allowEdit': {
				type: Boolean
			},
			'associatedColumn': {
				type: String,
				required: true
			},
			'description': {
				type: String
			},
			'filter': {
				type: Object
			},
			'identifier': {
				type: Object
			},
			'schema': {
				type: Object,
				required: true
			},
			'title': {
				type: String
			}
		},
		watch: {
			computedRecord (val) {
				this.records = [val];
			}
		}
	};
</script>

<style lang="scss" scoped>
	ul {
		list-style-type: none;
		padding: 0;
	}
</style>
